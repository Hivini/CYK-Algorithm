import 'dart:collection';

import 'Graph.dart';
import 'generator.dart';
import 'node.dart';

class CYK_Algorithm {
  String w;
  String s;
  Node _root;
  bool accepted;
  Graph derivationTree;
  List<Generator> generators;
  HashMap<String, List<Generator>> processedStrings;
  HashMap<String, HashMap<String, List<Generator>>> paths;

  CYK_Algorithm(String w, List<Generator> generators, String s) {
    this.w = w;
    this.s = s;
    this.generators = generators;
    _root = Node(this.s);
    processedStrings = HashMap<String, List<Generator>>();
    paths = HashMap<String, HashMap<String, List<Generator>>>();
    _process();
    if (accepted) {
      _getPath(w, _root);
      derivationTree = Graph(_root);
      print('Derivation tree generated in data.js');
    }
  }

  void _process() {
    // Process the base generators.
    for (var i = 0; i < w.length; i++) {
      var charGenerators = <Generator>[];
      for (var gen in generators) {
        if (gen.hasArgument(w[i])) {
          charGenerators.add(gen);
        }
      }
      // Add the generators of the character.
      for (var gen in charGenerators) {
        if (!processedStrings.containsKey(w[i])) {
          processedStrings[w[i]] = <Generator>[];
        }
        if (!processedStrings[w[i]].contains(gen)) {
          processedStrings[w[i]].add(gen);
        }
      }
    }
    // Create the rest of the generators using the base ones.
    for (var step = 2; step < w.length + 1; step++) {
      for (var y = 0; y < w.length + 1 - step; y++) {
        var stepString = w.substring(y, y + step);
        if (stepString.length > 2) {
          processedStrings[stepString] = <Generator>[];
          // Get all the string combinations.
          for (var i = 1; i < stepString.length; i++) {
            var subLeft = stepString.substring(0, i);
            var subRight = stepString.substring(i, stepString.length);
            // Get the generators of the right and left
            var labels = <String>[];
            var gens = processedStrings[subLeft];
            if (gens.isNotEmpty) {
              for (var gen in gens) {
                labels.add(gen.label);
              }
              gens = processedStrings[subRight];
              if (gens.isNotEmpty) {
                var newLabels = <String>[];
                for (var gen in gens) {
                  for (var i = 0; i < labels.length; i++) {
                    newLabels.add(labels[i] + gen.label);
                  }
                }
                labels = newLabels;
              } else {
                labels = <String>[];
              }
            }
            // Search the labels
            var resultLabels = _searchByLabel(labels);
            processedStrings[stepString].addAll(resultLabels);
            if (!paths.containsKey(stepString)) {
              paths[stepString] = HashMap<String, List<Generator>>();
            }
            var newKey = subLeft + ',' + subRight;
            if (!paths[stepString].containsKey(newKey)) {
              paths[stepString][newKey] = <Generator>[];
            }
            paths[stepString][newKey].addAll(resultLabels);
          }
        } else {
          // Get the generators of the substrings of length two.
          if (!processedStrings.containsKey(stepString)) {
            processedStrings[stepString] = <Generator>[];
            var labels = <String>[];
            var gens = processedStrings[stepString[0]];
            for (var gen in gens) {
              labels.add(gen.label);
            }
            gens = processedStrings[stepString[1]];
            for (var gen in gens) {
              for (var i = 0; i < labels.length; i++) {
                labels[i] = labels[i] + gen.label;
              }
            }
            // Search the labels.
            var searchedLabels = _searchByLabel(labels);
            processedStrings[stepString] = searchedLabels;
            if (searchedLabels.isNotEmpty) {
              if (!paths.containsKey(stepString)) {
                paths[stepString] = HashMap<String, List<Generator>>();
                if (!paths[stepString].containsKey(stepString)) {
                  paths[stepString][stepString] = <Generator>[];
                  paths[stepString][stepString].addAll(searchedLabels);
                }
              }
            }
          }
        }
      }
    }
    // Check if the S generator is in the final result
    var finalGens = processedStrings[w];
    var hasStart = false;
    for (var gen in finalGens) {
      if (gen.label == s) {
        hasStart = true;
        break;
      }
    }
    if (hasStart) {
      print('The string can be generated by the grammar');
      accepted = true;
    } else {
      print('The string cannot be generated by the grammar');
      accepted = false;
    }
  }

  List<Generator> _searchByLabel(List<String> labels) {
    var generatedByLabel = <Generator>[];
    for (var label in labels) {
      for (var gen in generators) {
        if (gen.hasArgument(label)) {
          generatedByLabel.add(gen);
        }
      }
    }
    return generatedByLabel;
  }

  void _getPath(String w, Node root) {
    String subSet;
    for (var key in paths[w].keys) {
      var found = false;
      for (var val in paths[w][key]) {
        if (val.label == s) {
          subSet = key;
          found = true;
          break;
        }
      }
      if (found) break;
    }
    var left = subSet.split(',')[0];
    var leftNode = Node(processedStrings[left][0].label);
    root.addChild(leftNode);
    _getPathRecursive(left, leftNode);
    var right = subSet.split(',')[1];
    var rightNode = Node(processedStrings[right][0].label);
    root.addChild(rightNode);
    _getPathRecursive(right, rightNode);
  }

  void _getPathRecursive(String w, Node root) {
    if (w.length < 2) {
      for (var gen in generators) {
        if (gen.hasArgument(w)) {
          root.addChild(Node(w));
          return;
        }
      }
    } else if (w.length == 2) {
      for (var gens in paths[w][w]) {
        if (gens.label == root.label) {
          var left = w[0];
          var leftNode = Node(processedStrings[left][0].label);
          root.addChild(leftNode);
          _getPathRecursive(left, leftNode);
          var right = w[1];
          var rightNode = Node(processedStrings[right][0].label);
          root.addChild(rightNode);
          _getPathRecursive(right, rightNode);
        }
      }
    } else {
      var g = paths[w];
      for (var subs in g.keys) {
        for (var gens in paths[w][subs]) {
          if (gens.label == root.label) {
            var left = subs.split(',')[0];
            var leftNode = Node(processedStrings[left][0].label);
            root.addChild(leftNode);
            _getPathRecursive(left, leftNode);
            var right = subs.split(',')[1];
            var rightNode = Node(processedStrings[right][0].label);
            root.addChild(rightNode);
            _getPathRecursive(right, rightNode);
          }
        }
      }
    }
  }
}
